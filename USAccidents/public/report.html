<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Report used to explain details of the development process">
    <title>US Accidents Visualizer</title>
    <link rel="icon" type="image/png" href="/icons/flag.svg.png" />
</head>

<body>

    <h1> US Accidents Visualizer Report</h1>

    <div role="contentinfo">
        <ol role="directory">
            <li><a href="#abstract">Abstract</a></li>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#arhitecture">Project architecture</a>
                <ul>
                    <li><a href="#arhitecture_1">Details</a></li>
                    <li><a href="#arhitecture_1">Components</a></li>
                    <li><a href="#arhitecture_1">Application flow</a></li>
                </ul>
            </li>
            <li><a href="#db">Database</a></li>
            <li><a href="#mvc">MVC Model</a></li>
            <li><a href="#ms">Microservices</a></li>
            <li><a href="#usecases">Use-cases</a></li>
            <li><a href="#API">API's</a></li>
            <li><a href="#technologies">Technologies</a>
            <li><a href="#services">Services</a>
            <li><a href="#bibliography">Bibliography & Sources</a>
        </ol>
        <dl>
            <dt>Authors</dt>
            <dd>
                Aftanase Cosmin
                &amp;
                Apostol Adrian
                &amp;
                Barsan Alexandru
            </dd>
        </dl>
    </div>

    <section id="abstract">
        <h1> 1. Abstract </h1>
        <p>This application represents a flexible web tool used for data visualzation of accidents in the USA.</p>
        <!-- Sa se dezvolte un instrument Web de vizualizare flexibila a datelor vizand accidentele din SUA, 
        pe baza unui API REST/GraphQL propriu. Statisticile si vizualizarile generate – minim 3 maniere + 
        redari cartografice pe baza unor servicii Web de profil – vor putea fi exportate in formatele CSV, PNG si SVG. 
        Sistemul va oferi suport si pentru cautarea multi-criteriala de incidente raportate. Resurse suplimentare despre 
        vizualizarea datelor:  -->
    </section>

    <section id="introduction">
        <h1> 2. Introduction </h1>
        <p> This website offers the user the posibility to manipulate data using interactive tools.</p>
        <p> It provides a multi-criterial search to show different graphs and cartographical representations of a 3
            million record document
            regarding accidents from the USA.
        </p>
    </section>

    <section id="arhitecture">
        <h1 href="#mvc"> 3. Architecture </h1>
        <p id='arhitecture_1'>3.1 Details</p>
        <p id='arhitecture_2'>3.2 Components</p>
        <p id='arhitecture_3'>3.3 Application flow</p>
    </section>

    <section id="db">
        <h1 href="#db"> 4. Database </h1>
        <p> MongoDB stores accidents data, admin credentials, and available values for the
            multi-criterial search tool. </p>
    </section>


    <section id="mvc">
        <h1 href="#mvc"> 5. MVC </h1>
        <p><b>5.1 Model</b></p>
        <p>
            The Model is responsible for getting and manipulating the data, so it's basically the brain of the
            application.
            It interracts with MongoDB, where it stores accidents data, admin user data, and available values for the
            multi-criterial search tool.
        </p>
        <p><b>5.2 View</b></p>
        <p>
            Next, we have the view and you can probably guess what that takes care of. That's the actual view of the
            application, so it's the user interface, it's what the user sees and how they interact with the application.
            So the view usually consists of HTML and CSS along with dynamic values from the controller. So the
            controller communicates with the view as well as the model. Now, depending on which framework you use, the
            template engine may vary.
            The template engine is what allows dynamic data. If we have straight HTML, we can't output variables, we
            can't use logic, select an if statement, etc., but, with template engines, we can do that stuff right in the
            view or right in the template.
        </p>
        <p><b>5.3 Controller</b></p>
        <p>
            So, finally, we have the controller and the controller takes in user input, so this could be from the user
            visiting a page or clicking a link which makes a get request or submitting a form which makes a post request
            and we also have delete requests or put requests for updating. And these can't be made directly from the
            browser, you can only do a get or a post but we do have HTTP clients that are at times built in with the
            framework, that can do that.

            Now the controller acts as kind of a middleman between the model and the view. The controller will ask the
            model to get some data from a database and then the controller will take that data and load a view and pass
            that data into it. Then, from there, the template engine takes over and can basically do some logic, output
            variables, and things like that.

            The controller can also load a view without passing it data, so just a plain web page with HTML and CSS, no
            actual templating logic.

            Here's a very simple example or diagram.
        </p>
        <img src='/icons/mvc-architecture.png' alt="MVC Architecture" type="image/png"
            href="/icons/mvc-architecture.png" style="width: 40%; height:50%">
        <p>
            Now we have the user, who sees the view of the application in the browser, and the app can make some kind of
            requests with input to what's called a router. And their request could be some kind of link that they
            clicked on some kind of route.

            Then the router will call a specific controller method based on that route and if data is needed or if you
            need to fetch some data, the controller will then interact with the model, which interacts with the
            database. Then, once the controller gets that data passed back, it can then load a view and it can send the
            data to the view and it'll get dealt with by the template engine.


            Once that's all done it'll send the view back to the browser for the user to see.
        </p>
    </section>

    <section id="usecases">
        <h1 href="#usecases"> 7. Use-cases </h1>
        <ol>
            <li> The user enters the site and<b> views the map and the points where the accidents occurred according to the input criteria. </b></li>
            <li> The user enters the <b>main page</b> and can download the generated map in png, csv and svg format.</li>
            <li> The user enters the site <b>and can navigate to the other pages</b></li>
            <li> The user enters the <b>Heat Map</b> page and can view on the map each state with a different color depending on the criteria of the chosen accidents. </li>    
            <li> The user enters the <b>Heat Map</b> page and can download the generated map in jpg and csv format. </li>
            <li> The user enters the <b>Pie Chart</b> page and can view a pie chart with all states according to the chosen accident criteria.</li>
            <li> The user enters the <b>Pie Chart</b> page and can download the generated chart in jpg or csv format. </li>
            <li> The user enters the <b>Bar Graph</b> page and can view a graph in which on the horizontal axis is the number of accidents chosen according to the criteria, and on the vertical axis each state separately. </li>
            <li> The user enters the <b>Contact</b> page in which he can send an email to the project email. </li>
        </ol>
    </section>


    <section id="API">
        <h1 href="#API"> 8. API's </h1>
        <p> </p>
    </section>

    <section id="technologies">
        <h1 href="#technologies"> 9. Technologies </h1>
        <p><b>1. Node JS </b></p>
        <p> Node.js is an open source, cross-platform runtime environment for developing server-side and networking
            applications. Node.js applications are written in JavaScript, and can be run within the Node.js runtime on
            OS X, Microsoft Windows, and Linux.

            Node.js also provides a rich library of various JavaScript modules which simplifies the development of web
            applications using Node.js to a great extent.
        </p>
        <p> <b>2. MongoDB </b></p>
        <p> Stores accidents data, admin credentials, and available values in JSON format.</p>

        <p>
            <b> 3. HTML5, CSS3, JavaScript </b>
        </p>

        <p> HTML and CSS was used to create the UI, whereas JavaScript was used for creating functionalities and
            cartographical representations. 
        </p>
        
        <p>
            <b> 4. Version Control - Privare repository on GitHub </b>
        </p>
        <p>
            <b> 5. Cartographic representations </b>
        </p>
        <p>
            <b> 5.1 Google Charts </b> 
        </p>
        <p> Used to create heat map and pie chart representations.</p>
        <p>
            <b> 5.2 Openlayers </b> 
        </p>
        <p> Used to create ...</p>

        <b><p>Mocha testing</p></b>
        <p>We've used Mocha framework for testing GET requests on different routes, including a undefined route.</p>
        <p>The other suite tests wether the data that was added was also in dava_values database wich holds all the unique posible values for any given collumn. </p>
    </section>

    <section id="services">
        <h1 href="#services"> 10. Services </h1>
        <p> <b>Authorization</b> (decides wether you have the permission to access a resource)</p>

        <p>
            The auth service lets the user login as administrator using a POST request, sending a username and a password;
            If the credentials are correct, the user gets a JWT, used for later authentication.
            Then the user could send the JWT using a GET to verify the token.
            SQL Injection has been prevented by checking wether the '$' exists in the body requests, and if so, the whole body is turned into null;
        </p>
        <p>Before:</p>
        <p>
            <img src='/icons/before.webp' alt="MVC Architecture" type="image/png"
            href="/icons/before.webp" style="width: 70%; height:50%">
        </p>
        <p>After:</p>
        <p>
            <img src='/icons/after.webp' alt="MVC Architecture" type="image/png"
            href="/icons/after.webp" style="width: 70%; height:50%">
        </p>
        <p>
            The register service requests a JWT to create a new account, meaning the user needs to auth first in order to get the JWT.
            Afterwards, the user could create new accounts using POST request, sending the username and password in the body of the request.
        </p>

    </section>


    <section id="bibliography">
        <h1 href="#bibliography"> 11. Bibliography </h1>
        <p><a href = 'https://dzone.com/articles/introduction-to-mvc-architecture-web-developer-poi'> https://dzone.com/articles/introduction-to-mvc-architecture-web-developer-poi </a> </p>
        <p><a href = 'https://www.tutorialspoint.com/nodejs/nodejs_introduction.htm'>https://www.tutorialspoint.com/nodejs/nodejs_introduction.htm</a> </p>
        <p><a href = 'https://developers.google.com/chart'>https://developers.google.com/chart</a></p>
        <p><a href = 'https://openlayers.org/'>https://openlayers.org/</a></p>
    </section>

</body>

</html>